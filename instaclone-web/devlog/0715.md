# ğŸ’¡ DEVLOG 7/15

- real-time stuff

### #7.7 Subscription Setup part 1

- subscription : long-lasting GraphQL read operation
- PubSubEngine(publish-subscribe) í•„ìš” (ì•„í´ë¡œ ì„œë²„ì— ë‚´ì¥ - êµìœ¡ìš©, ì‹¤ì œì„œë¹„ìŠ¤ - Redis PubSub ì„œë²„ ì‚¬ìš©)

1. engineì˜ pubsub instance ë§Œë“¤ê¸°

```js
// pubsub.js

import { PubSub } from "apollo-server=express";

const pubsub = new PubSub();

export default pubsub;

// server.js
import pubsub from "./pubsub";
```

2. ë³€ê²½ëœ ì‚¬í•­ì— ëŒ€í•´ listen( subscribe)
   - ëŒ€í™”ë°©ì˜ ìƒˆë¡œìš´ ë©”ì„¸ì§€ë¥¼ listen (**NEW_MESSAGEë¼ëŠ” ì´ë²¤íŠ¸ë¥¼ subscribe--listening**)

```js
// roomUpdates.typeDefs
type Subscription {
    roomUpdate : Message
}

// roomUpdates.resolvers
Subscription : {
        roomUpdates : {
            subscribe : () => pubsub.asyncIterator(NEW_MESSAGE)
        }
    }

// constants.js
export const NEW_MESSAGE = "NEW_MESSAGE"
```

3. playgroundì—ì„œ subscribe

```
subscription {
  roomUpdates {
    payload
  }
}
```

- ğŸ’¦ error : `"Could not connect to websocket endpoint ws://localhost:4000/graphql` 

  -> httpëŠ” stateless (request-> response -> end) í•˜ê¸°ë•Œë¬¸

  -> **ì›¹ì†Œì¼“(ws)**ëŠ” connectionì„ ì—´ê³  ì‹¤ì‹œê°„ìœ¼ë¡œ ì£¼ê³ ë°›ìŒ

- ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ì„œë²„ëŠ” wsë¥¼ ë‹¤ë£° ì¤„ ëª¨ë¥´ê¸°ë•Œë¬¸ì— subscriptionì— ëŒ€í•œ ì§€ì‹ì„ ì„œë²„ì— ì„¤ì¹˜í•´ì•¼í•¨

```js
// server.js ì— ì¶”ê°€
apollo.installSubscriptionHandlers(app);
```



### #7.8 Subscription Setup part 2

- Setup
  - http ì„œë²„ ìƒì—ì„œ listen
  - our server is handling two different protocols(http, ws)

```js
// server.js

import http from "http"; // ì¶”ê°€

apollo.installSubscriptionHandlers(app); // ì‚­ì œ

const httpServer = http.createServer(app); // ì¶”ê°€
apollo.installSubscriptionHandlers(httpServer)

httpServer.listen(PORT, () => { ... // ìˆ˜ì •
```

- ğŸ’¦error :  `"Cannot read property 'headers' of undefined"`
  - ì›¹ì†Œì¼“ì€ request, responseê°€ ì—†ìŒ (ëŒ€ì‹  connectionì´ë€ê²Œ ìˆìŒ)

```js
context: async ({ req }) => {
        return {
            loggedInUser:
                              // ì´ë¶€ë¶„
                await getUser(req.headers.token),
        };
    }
```

- if (req) { ~} ë¡œ ìˆ˜ì •í•˜ê³  playgroundì—ì„œ ì‹¤í–‰



**How/Where to publish the event(NEW_MESSAGE)**

- after creating a message, publish the event
- `pubsub.publish(triggerName,payload)`
  - payload needs to be an object (name_of_subscription : return type of subscription)

```js
// sendMessage.resolvers
const message = await client.message.create({...})
pubsub.publish(NEW_MESSAGE, { roomUpdates: { ...message } });
// "message" objectê°€ ì•„ë‹ˆë¼ ê·¸ ì•ˆì˜ ë‚´ìš©ì´ í•„ìš”

return {...}

```

- ê°„ë‹¨ì •ë¦¬

1. **subscribe** : asyncIteratorë¥¼ ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ í•¨ê»˜  return (roomUpdates.resolvers)
2. **publish** : ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ payloadë¥¼ publish (sendMessage.resolvers)



**when should i use subscription?**

- small, incremental changes to large objects (ex. ì¢‹ì•„ìš” ê°œìˆ˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸)
- low-latency, real-time updates (ex. chatting)



### #7.9 Filtering subscription part 1

- ì•„ì§ ì•ˆì „í•˜ì§€ x (í•„í„°ë§ ì—†ì´ ëª¨ë“  roomì˜ ë³€í™”ë¥¼ listeningí•˜ê³  ìˆìŒ)

**í•„í„°1** : listení•˜ê³  ì‹¶ì€ roomIdë¥¼ argumentë¡œ ë°›ê¸°

```js
// roomUpdates.typeDefs
type Subscription {
        roomUpdates (id:Int!): Message
    }
```

- **withFilter()** ì‚¬ìš©

  - `withFilter(function that returns async iterator, filter function(payload, variables))` 

    **if filter function returns true : user will get updates**

```js
// roomUpdates.resolvers.js
Subscription: {
        roomUpdates: {
            subscribe: withFilter(
                () => pubsub.asyncIterator(NEW_MESSAGE), // function that returns asyncIterator
                ({roomUpdates}, {id}) => {  // filter function (variablesì— argumentë¡œ ë³´ë‚¸ idê°€ í¬í•¨ë¨)
                    return roomUpdates.roomId === id;                }
                // ë³´ë‚¸ ë©”ì„¸ì§€ì˜ roomIdê°€ update ë°›ê³ ìí•˜ëŠ” room id(argumentë¡œ ë„£ì–´ì¤€)ì™€ ê°™ì„ ë•Œ return true
                // then update ì‹¤í–‰
            )
        }
    }
```

- ê²°ê³¼ : roomUpdates(id:5) ë¥¼ ì‹¤í–‰í•˜ë©´ sendMessage(roomId:1) í•´ë„ ì—…ë°ì´íŠ¸ë˜ì§€ ì•ŠìŒ (5ë²ˆë°©ì— ëŒ€í•´ì„œë§Œ ì—…ë°ì´íŠ¸í•˜ê¸° ë•Œë¬¸)

**í•„í„°2** : ì¡´ì¬í•˜ì§€ ì•ŠëŠ” roomì— ëŒ€í•´ì„œëŠ” listening  í•˜ì§€ ì•Šê¸°

**í•„í„°3** : subscription resolverë¥¼ authenticationìœ¼ë¡œ ë³´í˜¸ (protectedResolverëŠ” ì˜ ì‘ë™í•˜ì§€ ì•Šì„ ê²ƒì„ ) - update ë°›ê³ ì í•˜ëŠ” userê°€ ëŒ€í™”ë°©ì˜ ì°¸ì—¬ìê°€ ë§ëŠ”ì§€ í™•ì¸



### #7.10 Filtering Subscription part 2

**í•„í„°2** : ì¡´ì¬í•˜ì§€ ì•ŠëŠ” roomì— ëŒ€í•´ì„œëŠ” listening  í•˜ì§€ ì•Šê¸°

- subscription field should return "calling function"(?), not returning function
- withFilter becomes resolver
- same with protectedResolver(function returning other function)

```js
// roomUpdates.resolvers

roomUpdates: {
            subscribe: async (root, args, context, info) => {
                const room = await client.room.findUnique({
                    where: {
                        id: args.id,
                    },
                    select: {
                        id: true
                    }
                })
                if (!room) {
                    throw new Error("you shall not see this.");
                }
                return withFilter(
                    () => pubsub.asyncIterator(NEW_MESSAGE),
                    ({ roomUpdates }, { id }) => {
                        return roomUpdates.roomId === id
                    }
                )(root, args, context, info)
                // subscription field shouldn't return "function"
            }
        }
```



### #7.11 Authentication Subscription

**í•„í„°3** : updateë¥¼ ë¦¬ìŠ¤ë‹í•˜ëŠ” userë¥¼ ì¸ì¦

ë¬¸ì œ : tokenì´ http headerë¡œ ë³´ë‚´ì§€ê³  ìˆìŒ (wsì—ì„œëŠ” ì–´ë–¤ ì¸ì¦ë„ í•˜ì§€ ì•Šê³  ìˆìŒ) -> websocket worldì—ì„œ loggedInUser ì— ì ‘ê·¼í•  ìˆ˜ ìˆì–´ì•¼í•¨

- apollo server - subscription - onConnect
  - **onConnectì˜ parameterì—ëŠ” http headerì˜ ë‚´ìš©ì´ ì „ë‹¬ë¨!** (userê°€ connectë¥¼ ì‹œë„í•  ë•Œë§Œ)

```js
// server.js
subscriptions: {
        onConnect: async ({ token }) => {
            if (!token) {
                throw new Error("You can't listen.")
            }

            const loggedInUser = await getUser(token);
            return {
                loggedInUser
            }
        }
    }
```

- **onConnectì—ì„œ ë¦¬í„´ëœ loggedInUserëŠ” contextì˜ connection ë‚´ì— ë‹´ê¹€**

```js
connection : {
    context : { loggedInUser : [Object]}
}
```

- updateRoom resolverë¡œ loggedInUserê°€ ë‹´ê¸´ context ì „ë‹¬

```js
// server.js

context: async (ctx) => {
        if (ctx.req) {  // http context 
            return {
                loggedInUser:
                    await getUser(ctx.req.headers.token),

            };
        } else {      // websocket context
            return {
                loggedInUser: ctx.connection.context.loggedInUser
            }
        }
    },
```



```js
// roomUpdates.resolvers

const room = await client.room.findFirst({ // findUnique ì‚¬ìš© ë¶ˆê°€(usersëŠ” uniqueí•œ í•„ë“œ ì•„ë‹˜)
                    where: {
                        id: args.id,
                        users: {  // ì¶”ê°€
                            some: {
                                id: context.loggedInUser.id,
                            }
                        }
                    },
```

ğŸ”¼ **userê°€ listeningì„ ì‹œì‘í•˜ê¸° ì „ì— ì²´í¬ **

ğŸ”½ **userê°€ listening í•œ í›„ì— ì²´í¬**

- test : ë¨¼ì € listening í•œ í›„ì— kick yourself out of the room, then send message

```js
// roomUpdates.resolvers.js

// sendMessageì—ì„œ publish ë˜ì—ˆì„ ë•Œ ì‹¤í–‰
// => pubsub.publish(NEW_MESSAGE, { roomUpdates: { ...message } });

return withFilter(
                    () => pubsub.asyncIterator(NEW_MESSAGE),
                    async ({ roomUpdates }, { id }, { loggedInUser }) => {
                        
                        if(roomUpdates.roomId === id){
                            const room = await client.room.findFirst({
                                where: {
                                    id,
                                    users: {
                                        some: {
                                            id: loggedInUser.id,
                                        }
                                    }
                                },
                                select: {
                                    id: true
                                }
                            });

                            if(!room){
                                return false;
                            }
                            return true;
                        }
                    }
                )(root, args, context, info)
```



### #7.12 Recap

1. withFilter function ì€ íŠ¹ì • ìœ ì €ì—ê²Œ ë¦¬ìŠ¤ë‹ì„ í—ˆìš©í•˜ì§€ ì•Šì•„ì•¼ í•  ê²½ìš° ì‚¬ìš©(ëŒ€ë¶€ë¶„ì˜ ê²½ìš° filteringí•¨)

   public listening ì˜ ê²½ìš° : ê·¸ëƒ¥ ì´ë ‡ê²Œ ì“°ë©´ë¨!  `subscribe : () => pubsub.asyncIterator(NEW_MESSAGE),`

2. withFilter functionì€ ë‘ê°€ì§€ argumentë¥¼ ê°€ì§

   - iterator : if user has access to this, the user will listen to your server

   - function : userê°€ ê·¸ê²ƒì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ê±´ì§€ ê²°ì •, ë°˜ë“œì‹œ falseë‚˜ trueë¥¼ ë¦¬í„´í•´ì•¼í•¨

     falseë¥¼ ë¦¬í„´í•˜ë©´ ì—…ë°ì´íŠ¸ë¥¼ ë°›ì§€ ëª»í•¨

3. ìœ ì €ê°€ `pubsub.asyncIterator(NEW_MESSAGE)`ë¥¼ ë°›ìœ¼ë©´ subscriptionì„ ì—¼ =>  NEW_MESSAGE ì±„ë„ì— ë¬´ì—‡ì¸ê°€ publish ë˜ê¸¸ ê¸°ë‹¤ë¦¼

   sendMessage.resolverì—ì„œ publish : 

- triggerName : subscribe í–ˆë˜ ì±„ë„ì˜ ì´ë¦„ìœ¼ë¡œ publish

- payload : í˜„ì¬ subscribeí•˜ë ¤ í•˜ëŠ” mutationì˜ ì´ë¦„ + payload

  payloadì˜ íƒ€ì…ì€ subscribeí•˜ë ¤í•˜ëŠ” mutationì˜ ë¦¬í„´ íƒ€ì…ê³¼ ê°™ì•„ì•¼ í•¨ 

- `pubsub.publish(NEW_MESSAGE, {roomUpdates : {...message}});

4. subscriberì˜ contextì—ëŠ” loggedInUserê°€ ì—†ë‹¤ << ìš°ë¦¬ê°€ requestë¥¼ ì‚¬ìš©í•  ë•Œ ê·¸ê²ƒì€ http worldì—ì„œ ë™ì‘í•˜ê¸° ë•Œë¬¸ (there is no "request" in websocket world)
   - apollo knows this, and helps us w/ "onConnect"
   - onConnect is called only once when the user connects to your website (with websocket) - websocket : live connection (not like http)
   - onConnect functionì˜ ì²«ë²ˆì§¸ argumentëŠ” connection parameters(basically, http headers)
   - onConnect functionì˜ return value => goes to our resolver's context



5. `return withFilter(...)(root, args, context,info)`

   - withFilter functionì˜ í˜¸ì¶œë¡œ ì¸í•œ ê²°ê³¼ê°’ì„ return í•´ì•¼í•˜ê¸°ë•Œë¬¸(?????)

     ì•„ ì˜¤ì¼€ì´!! í•¨ìˆ˜ ìì²´(f)ë¥¼ ë¦¬í„´í•˜ë©´ ì•ˆë˜ê³  argument ë¥¼ ì ìš©í•œ ê²°ê³¼ê°’(f(x))ë¥¼ ë¦¬í„´í•´ì•¼í•˜ê¸°ë•Œë¬¸!!(ê²°ê³¼ê°’ì€ true or false)

6. checking twice (if user is **still** part of the room) : ì–´ë–¤ userê°€ ë¦¬ìŠ¤ë‹í•˜ê³  ìˆë‹¤ê°€ ë°©ì—ì„œ ì«’ê²¨ë‚˜ëŠ” ê²½ìš°



# FRONTEND INTRO

### #8.0 Create React App

- 2ê°œì˜ í”„ë¡ íŠ¸ì—”ë“œ
  - ì´ ì½”ìŠ¤ì—ì„œ ê°€ë¥´ì¹˜ëŠ” ê±°
  - react native web : ë‹¨ í•˜ë‚˜ì˜ ì½”ë“œë¡œ ios, android, ì›¹ì„ í•œë²ˆì— íƒ€ê²ŸíŒ…



### #8.1 What are we going to use

1. styled components
2. react hook form
3. react router
4. apollo client
5. react helmet
6. react-fontawesome

